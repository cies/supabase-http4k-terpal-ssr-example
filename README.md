http4k-ssr-with-supabase-auth-and-direct-sql
============================================

Dream stack.

* [Supabase](https://supabase.com) —
Can't beat their value proposition (auth, object store, scaling, REST, graphQL, subscriptions),
and just fall back to Postgres in case it does not fit.
* [Kotlin](https://kotlin.org) —
Beautiful language that anyone with typed OO experience (Java, C#, C++, modern PHP/Ruby/Python) can learn in a weekend.
Lift on Java's ecosystem for heavy-lifting. Better culture than Java wrt type-safety.
* [kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization) —
Powerful and minimalistic (no reflection) lib for decoding/encoding JSON.
Terpal (below) also uses this, and we have built a form data parsing lib on top of it.
* [kotlinx.html](https://github.com/Kotlin/kotlinx.html) —
Write HTML templates in Kotlin's DSL syntax, adds type safety where possible.
* [http4k](https://https4k.org) —
The same architectural model as Rails+Rack (Ruby), or Axum+Tower (Rust) or <many other> use,
well implemented in as a bunch of libs Kotlin. Very modular. Very pluggable.
* [terpal-sql](https://github.com/ExoQuery/terpal-sql) —
Does not interfere with SQL code at all (not an ORM or query builder), so 100% "just SQL". (Similar to Jdbi or JDBC.)

The idea is to have Supabase with all the value it brings to the table ready to be used directly from the browser if needed,
while being able to start of with a traditional SSR application.
This because SSR is less expensive to implement than an SPA.
SPAs force one to manage the state twice and reimplement lots of browser features in JS
(back/forward button behaviour, while remembering scroll/form state, etc.).


### Authentication

We use JWTs for authentication. Since this is primarily a server-side rendered application,
the rotating refresh token scheme is not useful for us.
Therefor we use long-lived JWT access tokens for authentication
(a `session_id` does exist, but it is not exposed by the auth service).
These tokens are valid for 100 hours (about half a week) and will be rotated on first use
after the first 50 hours of the expiry time have passed.

This requires the following setting in Supabase's `conifg.toml`:

```toml
jwt_expiry = 360000
```


### Authorization

For read queries we define RLS policies, for write queries we **do not**.
This is an explicit design choice:

* read policies tend to be simpler
* they allow for stronger guarantees against data leaks
* in many cases the autogenerated APIs Supabase offers (REST, GraphQL, realtime)

For modification queries ---for now--- we dont use RLS: all are forbidden.
Maybe someday they can be useful, but for now we hold on this hard rule.

Changes thus all should be made through the application layer,
in there you wrap `db.withServiceRole(req) { ... }` around write statements.


### Project goals

* Authentication and authorization the Supabase way, directly with SQL from the backend code,
by a `Filter` (http4k concept meaning "for all endpoints that build on top").
* Quick developer cycles.
* Pretty error pages. Useful error pages in development.
* Total control of the db queries being made. 100% PGSQL.
* Full control over the use of db transactions (nesting of transactions is allowed),
and no transaction is started automatically per request cycle.
* 12-factor principles (like: configuration by env vars).


### Minimalism

There's a custom task in the Grade file to print the sizes of the dependencies (`depsize-all-configurations`).
I proudly show its output here:

```
  1683 KB  kotlin-stdlib-2.1.20.jar
  1510 KB  kotlinx-coroutines-core-jvm-1.8.1.jar
  1063 KB  postgresql-42.7.3.jar
   865 KB  kotlinx-html-jvm-0.11.0.jar
   836 KB  http4k-core-6.9.2.0.jar
   771 KB  okhttp-4.12.0.jar
   648 KB  kotlinx-datetime-jvm-0.6.0.jar
   382 KB  kotlinx-serialization-core-jvm-1.8.1.jar
   351 KB  okio-jvm-3.6.0.jar
   288 KB  config-1.4.1.jar
   270 KB  supabase-http4k.jar
   270 KB  kotlinx-serialization-json-jvm-1.8.1.jar
   246 KB  terpal-sql-core-jvm-2.0.0.PL-1.2.0.jar
   225 KB  checker-qual-3.42.0.jar
   198 KB  terpal-sql-jdbc-jvm-2.0.0.PL-1.2.0.jar
   198 KB  http4k-realtime-core-6.9.2.0.jar
   158 KB  HikariCP-5.1.0.jar
   148 KB  konform-jvm-0.11.0.jar
   106 KB  kotlin-logging-jvm-7.0.7.jar
    96 KB  http4k-format-core-6.9.2.0.jar
    68 KB  slf4j-api-2.0.17.jar
    59 KB  http4k-config-6.9.2.0.jar
    56 KB  http4k-format-kotlinx-serialization-6.9.2.0.jar
    35 KB  atomicfu-jvm-0.23.1.jar
    29 KB  annotations-24.1.0.jar
    28 KB  http4k-client-okhttp-6.9.2.0.jar
    27 KB  result4k-2.22.3.0.jar
    22 KB  terpal-runtime-jvm-2.1.0-2.0.0.PL.jar
    15 KB  slf4j-simple-2.0.17.jar
     0 KB  kotlin-stdlib-jdk8-1.9.10.jar
     0 KB  kotlin-stdlib-jdk7-1.9.10.jar
---------------
TOTAL: 11M build/distributions/supabase-http4k.tar
```

Which is the result of:

```sh
tar -tvf build/distributions/supabase-http4k.tar | \
  awk '/.jar$/ {size=$3; split($6,path,"/"); jar=path[length(path)]; printf "%6d KB  %s\n", size/1024, jar;}' | \
  sort -nr
echo "\n---------------\nTOTAL:" $(ls -sh build/distributions/supabase-http4k.tar)
```

11MB (excluding the JVM) for a stack as featureful as this is an amazing feat!

On my machine (Intel Core Ultra 7 155H) it:
* compiles (`./gradlew clean; ./gradlew build -x test`) in 4 seconds,
* re-compiles under a second, and
* starts in ~300 ms.


**TODO**: Make a custom JVM setup with `jlink`.
Since the libraries are so minimalistic, I should be possible to reduce the size of JVM as well.
This should result in small and fast loading Docker images.


### Tech that did not make it

In this endeavour to make a "dream stack" I also looked into other directions.

I looked into Axum (on Rust), a very similar library-based web framework compared to http4k.
But I found Rust to be hard to work with, harder than needed for the job-at-hand:
this stack needs to perform well, but not "top percentile on the TechEmpower benchmark" well.
Also, there were a lot of concepts to learn in Rust; that would slow down new hires w/o Rust experience.
Kotlin, o.t.o.h, is straightforward to learn for those with previous statically-type OO experience.

The Dream web framework (on OCaml) was also considered. But the ecosystem simply was not there yet.
I want to move fast so libraries need to be readily available.
Also, OCaml suffers --like Rust-- from a significantly steeper learning curve than Kotlin.

Finally, on my programming language short list there was Gleam.
Actually a really strong contender, but a little young. Will it still be available in 5 or 10 years?

So Kotlin + http4k (the Kotlin-based webserver that works the way I want it to) it was.

SQLDelight, Jdbi and `terpal-sql` were also compared.
I found that SQLDelight --unlike the others-- did not allow me to use all of SQL, but only the subset they support.
They also have trouble keeping their IntelliJ plugin up to date
(their backing company does not devote the resources to it to keep it current).
Jdbi and `terpal-sql` are truly "just SQL" libraries and thus allow me to write any SQL Postgres can handle.
`terpal-sql` was BY FAR the smallest option in terms of added dependency size.
Since it builds on `kotlinx.serialization` I have moved some other code over to use that JSON lib as well,
so I could remove all Moshi/Jackson/kotlin-reflect usage, and drop the total stack size dramatically.

I also did a shoot-out between JTE/KTE and `kotlinx.html`.
While JTE/KTE is faster (both runtime and compile time), I found it to be clunky to use and hard to do true type-safety.
So I ended up with `kotlinx.html`, I'll look into things to mitigate its slow (incremental) compile times.


### TODO

* walk through all flows again
* implement some IP + extras logging in
* look into using "arch tests"
